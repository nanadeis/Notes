# 海量日志数据，提取出某日访问百度次数最多的那个IP  
最多有2^32个ip，可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文件中出现频率最大的ip及相应频率，再找出这1000个最大的ip中频率最大的ip  

# Top-K  
先对这批海量数据进行预处理，在O（N）时间内用hash表完成统计  
借助大小为k的堆这个数据结构，找出Top K，时间复杂度NlogK  

# 给两个1T的文件在2g ram的内存中找出相同项


# bitmap
## 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

解法一：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

解法二：也可采用与第1题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。”

## 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

解法一：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。

解法二：每个数用32位的二进制表示，一开始放在一个文件里  
将这40亿个数分成两类，最高位为0、最高位为1，将这两类分别写入两个文件中，与要查找的数的最高位比较并接着进入相应的文件再查找，再按照次高位划分。依次类推  


# 布隆过滤器  
用于判断一个元素在不在一个集合里  
一个很长的二进制向量,位数组  
一系列随机函数(哈希)  
空间和查询效率高,但是有一定的误判率(哈希表是精确匹配)  
布隆过滤器添加元素:  
将要添加的元素的k个哈希函数得到的位置都置为1  
布隆过滤器查找元素:  
将要查找的元素通过k个哈希函数得到k个位置,如果位数组的这k个位置有任意一个为0,则元素一定不再集合中.若全为1,则可能在集合中(有一定误判率,不一定在集合中)  

