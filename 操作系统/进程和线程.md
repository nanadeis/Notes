# 进程和线程的区别
进程是操作系统资源分配的最小单位。进程有独立的虚拟私有地址空间，如果fork出一个子进程，会拷贝地址空间，文件描述符（保存在操作系统的进程表中的打开文件描述符表项，也就是说会另开一个进程表）等资源会拷贝一份。但是父子进程的文件描述符的文件指针指向同一个文件表。因为地址空间独立，进程间通信比较困难，需要专门的IPC。一个进程有一个主线程。

线程是CPU调度的最小单位。一个进程里的多个线程共享地址空间，共享文件描述符等资源。线程通信相对容易，但是因为可以访问相同的地址空间，多线程对共享数据的访问需要同步。

一个线程的上下文要比一个进程的上下文小得多，因此线程的切换也比进程快得多。
进程是按父子关系组织的，父进程可以等待子进程结束（内核向父进程发送SIGCHD信号，wait和waitpid），但是子进程不能等待父进程结束（也可以让父进程结束时给子进程发送一个信号）。
同一进程中的线程是对等的，主线程只是因为是进程中的第一个线程才叫主线程。线程可以等待任意对等线程的结束（回收pthread_join()),可以杀死（pthread_kill(), pthread_cancel())任意对等线程【一个可结合的线程能够被其他线程回收或杀死，在被其他线程回收前它的内存资源是不会释放的。分离的线程（pthread_detach())不能被其他线程回收或杀死，线程结束时由内核自动释放资源。默认是可结合的】

# 任务队列  
内核把进程的列表存放在叫做任务队列的双向循环链表中  
链表中的每一项为进程描述符（类型为task_struct,在linux中，实际上一个线程就会对应一个task_struct。linux将线程视为一个与其他进程共享某些资源的进程)      
进程描述符中包含的数据能完整地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态等等  

# task struct（进程控制块PCB/进程描述符/进程表）    
## 进程管理  
寄存器  
程序计数器
程序状态字  
堆栈指针  
进程状态  
优先级  
调度参数  
进程ID  
父进程  
进程组  
信号  
进程开始时间  
使用的CPU时间  
子进程的CPU时间  
下次定时器时间   

## 存储管理  
mm 指向mm_struct(描述虚拟内存的当前状态)【线程的mm为NULL，线程切换的时候不切换虚拟内存空间，惰性TLB】

## 文件管理  



# 进程上下文  

# 中断上下文   

# 僵死进程 

# 孤儿进程  

# 线程上下文

# 进程间通信的方式
## **管道**  
只能用在有公共祖先的进程间（父子进程， 兄弟进程）。通常一个进程调用pipe创建管道。半双工，fd[0]读管道，fd[1]写管道。单个进程的管道没什么用，所以然后fork，子进程的fd[0]读同一个管道，fd[1]写同一个管道。

管道的本质是一个伪文件（实为内核缓冲区）  

在写读端关闭的管道（fd[0]的引用计数变为0），产生信号SIGPIPE。read写端关闭的管道返回1。

PIPE_BUF指明*内核*的管道缓冲区大小，当有多个进程写同一个管道，若要求写的字节数大于PIPE_BUF，则他们写的数据会相互交叉。

管道是有引用计数的，当最后一个引用管道的进程终止，管道就被完全的删除了。

 **FIFO** 也叫做命名管道
可用在没有关联的进程间。**FIFO是一种文件类型**  
 磁盘inode+管道 = 命名管道 FIFO文件的inode节点在磁盘上，但是仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同
当最后一个引用FIFO的进程结束，FIFO中的数据已经被删除了，但是FIFO的名字仍然留着系统中。

**消息队列、 信号量以及共享内存都是XSI IPC。每个内核中的IPC结构，都用一个非负整数的标识符加以引用，标识符是内部名。同时IPC都与一个全局唯一的key值关联，key值是外部名。**  

**XSI IPC的问题： IPC 结构是系统范围内起作用的，没有引用计数。如果一个进程创建了一个消息队列，放入了几则消息，然后终止。它们会一直留着系统里直到调用了msgrecv，msgctl或者ipcrm。**

linux命令ipcs，可以列出已有消息队列、Shared Memory Segments、semaphore array。可以用ipcrm命令删除遗留在系统中的共享资源。

**消息队列** 

msgget(key, flag)打开一个现有队列或创建一个新队列。返回消息队列标识符（ID）。
没有维护引用计数，当消息队列被删除，仍在使用该消息队列的进程对该消息队列的操作会出错返回。

**system V IPC 信号量（Semaphore）**   
信号量是一个计数器，P操作对信号量减一，若此时信号量为0，那么挂起。V操作对信号量加1.

**共享内存** 

共享一个给定的存储区，因为不需要在进程间拷贝数据，是效率最高的IPC。但是需要同步进程对共享内存的访问，否则会产生竞态条件。  **两个进程的虚拟内存的一个区域映射到同一块物理内存。**
shmget(key, size, flag)获取一段已经存在的共享内存或创建一段新的共享内存，返回共享内存标识符。
shmat和shmdt分别将共享内存关联到进程的地址空间，和将它从地址空间中分离。

## **socket** 
优点：  
传输数据为字节级，传输数据可自定义，数据量小效率高  
传输数据时间短，性能高  
适合于客户端和服务器端之间信息实时交互  
可以加密,数据安全性强  
缺点：需对传输的数据进行解析，转化成应用级的数据  

# 线程同步的方式  
## 临界区  
临界区（Critical section）指的是一个访问共享资源（例如：共享设备或是共享存储器）的程序片段，而这些共享资源有无法同时被多个线程访问的特性。  
临界区线程同步在Windows核心编程中被称为关键段线程同步，关键段是一小段代码，它在执行之前需要独占对一些资源的访问权。
缺点：能且只能用在一个进程中的多线程同步。可能陷入死锁，因为我们无法为进入关键段的线程设置最大等待时间。  
## **互斥锁**  
和二元信号量（system V）不同的是，只有加锁的线程才可以解这个锁（程序员应该这么用锁！）。互斥锁用于保护共享资源，信号量用于线程调度。
system V信号量保存在内核里IPC数据结构， mutex在用户内存里，可以是静态分配的，也可以是动态分配的，如果是动态分配的，在释放内存前要调用pthread_mutex_destroy  
如果有每个线程在没有得到锁也可以访问数据，那么还是会出现数据不一致的情况。  
如果释放互斥量时有一个以上线程阻塞，那么所有该锁上的阻塞线程都会变成**可运行状态（就绪）**，第一个变为**运行**的线程就可以对互斥量加锁，其他线程就会看到锁依然是锁着的，只能再次等待它重新变成可用。  
pthread_mutex_init 初始化互斥量
pthraed_mutex_lock 加锁
pthread_mutex_unlock 解锁

## **读写锁**  
当读写锁是写加锁状态，所有试图对这个锁加锁的的线程都会阻塞。当读写锁是读加锁状态，对这个锁读加锁的线程不会阻塞，写加锁的线程会阻塞。  
**写饥饿问题** 【写者优先】当读写锁处于读模式锁住的时候，此时有一个写模式获取锁在阻塞，读写锁通常会阻塞随后的读模式锁请求，避免读模式长期占有锁，写请求得不到满足。
pthread_rwlock_rdlock 读模式锁
pthread_rwlock_wrlock 写模式锁
pthread_relock_unlock 解锁

## **自旋锁**
和互斥量类似，但是并不使调用线程休眠而阻塞，而是忙等。
pthread_spin

## **条件变量**
条件变量用于调度线程。条件变量和互斥量一起使用，允许程序以无竞争的方式等待特定的条件发生。
pthread_cond_wait() 当条件为假时，阻塞
pthread_cond_signal() 唤醒cond_wait阻塞的线程

## **POSIX 信号量**  
和上述system V 信号量接口不同，但是语义相同。用sem_开头


# 进程的状态
运行态： 该进程实际占有CPU  
就绪态： 该进程可以运行，但是因为其他进程正在占有CPU而暂时停止  
阻塞态： 等待某种外部事件的发生，事件发生后才能运行

# 线程的状态  


# 用户模式和内核模式  
处理器必须提供一种机制，限制一个应用**可以执行的指令**和**可以访问的地址空间范围**。通常是在某个控制寄存器中有一个模式位，当设置了这个模式位，进程就运行在内核模式中，进程可以执行指令集中的所有指令，可以访问任何内存地址；反之，进程运行在用户模式，用户模式的进程不允许执行**特权指令**，如停止处理器，改变模式位，或者发起一个I/O操作。**也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据**， 用户进程必须通过系统调用接口间接地访问内核区的代码和数据。


# core dump


# 线程安全  


# fork函数  
一次调用两次返回，子进程返回0，父进程返回子进程的pid  
子进程是父进程的副本，经常使用写时复制的技术，正文段因为不可改变，所以父子进程总是共享正文段  







