# 信号
信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或者系统异常。  
例如，用户发送的：
输入Crtl+C，发送一个中断信号SIGINT；输入Crtl+Z，发送一个挂起信号SIGSTP。    
系统发送的：  
比如一个进程试图除以0，那么内核就发送给他一个浮点异常信号SIGFPE  
进程发送的：
进程通过kill函数发送信号

传送一个信号到目标进程由两个步骤组成：
1. 发送信号。**内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程**。发送信号可以有两种原因：1）内核检测到一个系统事件，如除0错误或子进程终止。2）一个进程调用了kill函数，显式的要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己  
2. 接收信号。当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接收了信号。  
有三种反应：  
1. 忽略此信号。SIGKILL(终止信号）和SIGSTOP（停止直到下一个SIGCONT信号）不能被忽略  
2. 捕捉信号。执行一个称为信号处理的用户层函数。SIGKILL和SIGSTOP也不能被捕获  
3. 执行系统默认动作  
一个发出而没有被接收的信号叫做待处理信号，任何时候，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都会被丢弃。  

# 发送信号  
int kill(pid_t pid, int sig)  
把sig信号发送给pid进程  

# 接收信号  
当内核把进程p从内核模式切换到用户模式时（如完成了一次系统调用，或者完成了一次上下文切换），它会检查进程p的未被阻塞的待处理信号的集合，如果集合非空，就会从中选择一个信号k强制p接收信号k。  
void （*signal（int signo， void(*func）（int）））（int）  
signal函数可以改变和信号signo相关联的行为  
更健壮的设置信号处理函数的接口是sigaction  

# 阻塞信号  
当一个信号被阻塞时，它任何可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞  
**内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号**  
sigprocmask函数可以明确地阻塞和解除阻塞选定的信号  

# 中断系统调用  
如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我们为该信号设置了信号处理函数（对于默认行为是暂停进程的信号，没有信号处理程序也可以），则默认情况下系统调用将被中断，并且errno被设置为EINTR。可以用aigaction函数为信号设置SA_RESTART标志以自动重启被信号中的系统调用。


# 线程和信号

# SIGKILL SIGSTOP SIGTERM SIGQUIT的区别  