# GCC编译器把源程序文件.c变成可执行程序文件的过程  
源码.c（文本） 【预处理器】.i（文本） 【编译器】.s（汇编程序，文本）【汇编器】.o(可重定位目标程序，二进制)【链接器】(可执行目标程序， 二进制)  

# 动态链接库  
## 生成动态链接库
gcc -shared -fpic 库名.so 
-fpic选项指示编译器生成与位置无关的代码  
-shared选项指示链接器创建一个共享的目标文件  

##加载动态链接库  
【加载可执行目标文件  
通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行可执行目标文件  
加载器将可执行目标文件中的代码和数据复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序  
在linux x86-64 代码段总是从0x400000开始  
】
当加载器加载和运行可执行文件时，加载部分链接的可执行文件。接着它注意到某一节包含动态链接器的路径名，动态链接器本身就是一个共享目标（如在linux系统上的ld-linux.so），加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成链接任务：
重定位动态链接库的文本和数据到某个内存段  
重定位可执行文件中对由动态链接库定义的符号的引用  


# 静态库和动态库的区别  


# include头文件  

## 顺序  
有从一般到特殊、从特殊到一般两种顺序  
但是源文件同名的头文件都要放在最前面，便于检查该头文件是否自完备，以及类型或函数声明是否与标准库冲突  

## “”和<>的区别  
“”，用户自定义的头文件，查找头文件的路径：  
1. 当前文件目录
2. 编译器设置的头文件目录，可使用-l显示指定搜索路径  
3. 环境变量CPLUS_INCLUDE_PATH指定的目录  
4. gcc的内定目录/usr/include、/usr/local/include、/usr/lib/gcc/x86_64-redhat-linux/4.1.1/include  
<>,系统自带的头文件，不搜索当前文件目录    
