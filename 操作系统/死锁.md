集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。  
# 死锁产生的原因  
系统资源不足  
资源分配不当  
进程运行推进顺序不合适  
# 产生死锁的四个必要条件  
互斥条件：某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有    
占有且申请条件：已经得到某个资源的进程可以再请求新的资源      
不可抢占条件：进程已获得的资源，在未使用完之前，不能被强行剥夺  
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系    
# 预防  
**打破互斥条件**：  
改造独占性资源为虚拟资源，大部分资源已无法改造。  
**打破不可抢占条件**：  
当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。  
**打破占有且申请条件**：  
1. 采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。【这种方法的问题：1.很多进程只有运行时才知道需要哪些资源，如果进程能够事前知道它要多少资源，可以使用银行家算法。 2. 资源利用率不是最优的】    
2. 当一个进程请求资源时，先暂时释放其当前占有的所有资源，然后再尝试一次获得所需的全部资源  
**打破循环等待条件**：  
实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。  

# 死锁检测
## 检测的时机  
当进程由于资源请求不满足而等待时检测死锁  
定时检测  
系统资源利用率下降时检测死锁  
## 每种类型一个资源的死锁检测  
资源分配图，若进程A持有R资源，且需要S资源，则 R->A->S，资源->进程:分配边，进程->资源：请求边    
若图中存在环则说明有死锁，环上的所有进程都处于死锁状态  

# 死锁恢复  
1. 利用抢占恢复  
2. 利用回滚恢复 
checkpoint  
3. 通过杀死进程恢复  

# 死锁避免  
在资源动态分配过程中，防止系统进入不安全状态。死锁避免从本质上来说是不可能的，因为它需要获知未来的请求，而这些请求是不可知的
### 安全状态
如果没有死锁发生，并且即使所有进程都突然请求对资源的最大需求，也仍然存在某种调度次序能使得每一个进程运行完毕，则称该状态是安全的。
不安全状态并不是死锁   
从安全状态出发，系统能保证所有进程都能完成。而从不安全状态出发，不一定。 
## 银行家算法  
首先有每个进程的已分配资源数（allocation），每个进程最多需要多少资源（max），当前有多少资源可用（available）  
当某个进程申请pi申请资源Requesti[j]时，系统**试探**着把该资源分配给进程P i，并修改下面数据结构中的数值：
Available[j]:= Available[j]-Request i[j]；
Allocation[i,j]:= Allocation[i,j]+Request i[j]；
Need[i,j]:= Need[i,j]-Request i[j]；
　　系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 
**检查一个状态是否安全的算法**：
 Allocation　　　Max　　　Available
 　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ
 P1   ００１４　　  ０６５６　　１５２０　
 P2　 １４３２　　  １９４２　
 P3　 １３５４　  　１３５６
 P4 　１０００　　  １７５０
求出need（需要多少资源），就是max - allocation。
工作向量work，初始work = available，向量Finish，初始全为False。
找出need比work小的进程pi，该进程可顺利执行，并释放分配给它的资源。Finish[pi] = true  
work = work + allocation[pi]  
迭代，如果所有进程的Finish都是true，则系统处于安全状态，否则处于不安全状态  
 
# 活锁  
在某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待1ms，再尝试一次。两个相同步调的礼貌的进程就会产生活锁。因为没有进程阻塞，所以不是死锁。
# 饥饿  
资源分配策略，可能使有的进程永远得不到服务。  