# new 运算符
new表达式的执行过程：  
1. 调用一个名为operator new（或operator new[])标准库函数。该函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象（或者对象的数组）
2. 编译器运行相应的构造函数以构造这些对象，并为其传入初始值。  
3. 对象被分配了空间并构造完成，返回一个指向该对象的指针。
c++支持重载，
# new 和 malloc 的区别  
1. **申请内存所在位置**  
malloc在堆上分配内存， new在自由存储区分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。取决于operator new的实现细节。自由存储区不仅可以是堆，也可以是静态存储区（全局变量做的对象池）。 【通常默认为堆】 

2. **是否调用构造函数/析构函数**  

3. **返回类型安全**  
new 返回对象的指针，无需类型转换，是类型安全的。malloc返回void *， 需要强制类型转换。  
4. **内存分配失败时的返回值**
new 抛出bac_alloc异常，它不会返回NULL。malloc分配内存失败时返回NULL  
5. **是否需要指定内存大小**  
new 无需指定内存大小，编译器会根据类型信息自行计算，而malloc需要显式地指出所需内存的尺寸。  
6. **对数组的处理**  
new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[] 要与new[]配套使用，不然会造成数组对象部分释放的现象，造成内存泄漏  

# sizeof  

# inline 内联函数  
相当于把内联函数里面的内容写在调用内联函数处，省去参数压栈、栈帧开辟和回收，结果返回等操作    
相当于不用执行进入函数的步骤，直接执行函数体  
相当于宏，却比宏多了类型检查，真正具有函数特性。内联函数在运行时可调试，而宏不能       
编译器一般不内联包含循环、递归、switch等复杂操作的内联函数  
在类声明中定义的函数，除了虚函数外会被自动隐式地当成内联函数，因此内联函数可以访问类的成员变量，而宏不能    
内联函数可以有多次定义，这些定义必须完全一致，因此通常定义在头文件里  
**缺点**
代码膨胀  
改变需要重新编译，而不是链接可以解决  
是否内联，取决于编译器  
## 虚函数（virtual）可以是内联函数（inline）吗？
虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。  
内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。


# assert（）  
断言，是宏而非函数。  
可以通过#define NDEBUG 关闭assert  









