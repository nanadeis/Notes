# 封装  

# 继承  

# 多态  
C++ 多态分类及实现：  
重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载  
子类型多态（Subtype Polymorphism，运行期）：虚函数  
参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板  
强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换  

# C++对象内存布局
构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）  
虚函数表在只读数据段
## 虚表指针、虚函数表  
当一个类定义了虚函数，或其父类有虚函数时，编译器为该类添加一个虚函数指针（vptr)。虚函数指针一般都放在对象内存布局的第一个位置上，这是为了保证在多层继承或者多重继承的情况下能够以最高效率取到虚函数表。  
虚函数指针指向虚函数表，虚函数表中存储的是一系列虚函数地址，虚函数地址出现的顺序与类中声明的顺序一致。  【虚函数地址指向只读代码段】
虚函数表的前面设置了一个指向type_info的指针，用以支持运行时类型识别。  
## 非继承下的c++对象模型
nonstatic 数据成员被置于每一个类对象中  
static数据成员，函数（不管是static的还是nonstatic的）都在类对象之外
virtual 函数通过虚函数指针+虚函数表来支持  
## 继承下的c++对象模型
### 单继承  
子类与父类拥有各自的一个虚函数表，若子类重写（overwrite）了父类的虚函数，则该子类虚函数地址将**覆盖**父类虚表中的函数地址。对于一般继承，若子类定义了新的虚函数，则该虚函数地址将扩充到虚函数表的后面。若为虚继承，则会增加一个新的虚表指针。  
### 一般的多继承（非菱形继承）  
子类新定义的虚函数被放在第一个父类的虚函数表的拷贝里  
overwrite时，所有基类的print()函数都被子类的print()函数覆盖。  
内存布局中，父类按其声明顺序排列  
### 虚继承  
虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）  


# 一个空类占几个字节，一个只有虚函数的类呢   -

1. 一个字节 编译器为空类安插一个字节，以便该类对象在内存得以配置一个地址。
2. 只有一个虚表指针,64位机器为8个字节  
3. 空类继承了一个空类：还是1个字节  
4. 空类继承了一个只有虚函数的类：还是只有一个虚表指针，8个字节  
5. 只有虚函数的类继承了一个只有虚函数的类：还是只有一个虚表指针，8个字节  

# 覆盖（override）、重写（overwrite）、重载（overload）的区别
重载：  
同名函数有不同的参数个数、类型，编译时多态
同一作用域，寻找适当函数的过程
重写：  
一般发生在子类和父类继承关系之间，子类重新定义父类中有相同名称和参数的**虚函数**。
在具体的实现时父类函数的指针会被子类相同的函数指针所覆盖，所以才称为overwrite
覆盖:
派生类函数覆盖基类函数 ，也叫做隐藏,子类重新定义父类中有相同名称的非虚函数 (参数列表可以不同) ，如果一个类，存在和父类相同的函数，那么，这个类将会覆盖其父类的方法，除非你在调用的时候，强制转换为父类类型，否则试图对子类和父类做类似重载的调用是不能成功的。

# C++的全局对象，进程启动时全局对象怎么保证，你一般用它来做什么；  


# 析构函数
析构顺序：
1. 执行析构函数体  
2. 成员按初始化顺序的逆序销毁  
3. 基类析构函数
## 为什么要将析构函数设置为虚函数 
将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。  
## c++默认的析构函数为什么不是虚函数  
C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。  

## 析构函数出现异常怎么捕获   
析构函数不应该抛出不能被它自身处理的异常。如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块当中，并且再析构函数内部得到处理  

# 构造函数  

## 构造函数出现异常怎么捕获  
构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的try语句块还未生效，所有构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常  
必须将构造函数写成函数try语句块（函数测试块，function try body）  
Bolb::Blob（int i） **try** ：data（i){ } **catch**（bad_alloc &e）{}


# this指针  
非静态成员函数都有，指向调用该成员函数的那个对象  
不能给this指针赋值，即this指针指向的对象不可更改  
this是一个右值，不能&this  
## delete this 合法吗？
合法，但：
必须保证 this 对象是通过 new（不是 new[]、不是 placement new【定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。new (place_address) type； place_address 是个指针】、不是栈上、不是全局、不是其他对象成员）分配的  
必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数  
必须保证成员函数的 delete this 后面没有调用 this 了  
必须保证 delete this 后没有人使用了  


# 用C实现C++类  
封装：使用函数指针把属性与方法封装在结构体里  
继承：结构体嵌套  
多态：父类与子类方法的函数指针不同  

# friend友元类和友元函数  
能访问私有成员  
破坏封装性  
友元关系不可传递  
友元关系的单向性  

# 成员初始化列表
好处  
更高效：少了一次调用默认构造函数的过程。  
有些场合必须要用初始化列表：  
常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面  
引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面    
没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化  


# 纯虚函数  
带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。


# 如何定义一个只能在堆上生成对象的类  
将析构函数设置为私有  
C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，若析构函数不可访问，则不能在栈上创建对象。  

# 如何定义一个只能在栈上生成对象的类  
将new和delete重载为私有  
在堆上生成对象，使用new关键词操作。  


# 访问权限  
## private  
类的用户代码不可以访问  

类的成员函数可以访问  
类的友元类/函数可以访问  
## protected   
类的用户代码不可以访问   
派生类对象不可访问

类的成员函数可以访问  
类的友元类/函数可以访问  
派生类的成员和友元可以访问 

## public  
私有继承的派生类的对象不可以访问  

## 派生访问说明符
**派生访问说明符对于派生类的成员及友元没有什么影响。而是控制派生类的用户（包括派生类的派生类）对于基类成员的访问权限**     

## using 改变个别成员的可访问性  
不能用来改变构造函数的可访问性