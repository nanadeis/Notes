# 浮点数在计算机的表示  
IEEE浮点表示，V = (-1)^s * M * 2^E  
32位的浮点数：
符号s，1位
阶码E，8位
尾数M是一个二进制小数，它的范围是1 ~ 2-epsilon, 或0 ~ 1-epsilon， 23位    

20971523 （十进制） = ‭0001010000000000000000000011‬ （二进制小数）  
= 1.010000000000000000000011‬ x 2^24  
因为M只有23bit，最末一位1只能舍弃  

# 金额不能用浮点数表示  


# 全局变量  
全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。  


# static的作用  
控制变量的存储方式和可见性  
## 为什么要引入static
栈上的变量会在函数结束时自动释放，如果想把函数中的值保留至下一层函数调用。全局变量也可以做到，全局变量有许多缺点，最明显的缺点是破坏了此变量的访问范围（使得在此函数中定义的变量，不仅仅受此函数控制）。
可见性： 需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。  
## 静态数据成员  
会被类的所有对象共享，包括派生类的对象  
必须初始化，通常在类的外部定义和初始化静态数据成员    
类似全局变量，静态数据成员定义在任何函数之外，因此一旦它被定义就存在于整个程序生命周期中。  
静态数据成员可以是不完全类型  
静态数据成员可以做默认实参  
## 静态成员函数
不包含this指针，因此不能声明为const的，仅能访问类的静态数据和静态函数。不能将静态成员函数定义为虚函数。 虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.  
与类实例无关。  
把类名当成namespace用。  
控制该函数的访问权限。  
控制类内的static变量。  
## 静态局部变量  
在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁。
修改了变量的存储区域和生命周期，但作用域仍为局部作用域  
内置类型的局部变量将不被初始化，一个未被初始化的内置类型的值是未定义的。静态局部变量则默认初始为0  

## 静态全局变量  
static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：

    （1）不会被其他文件所访问，修改

    （2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。
# 静态函数  
函数的定义和声明在默认情况下是extern的，但静态函数只是在声明他的文件中可用，不能被其他文件所用  

# extern
extern关键字表明函数和全局变量可以在本模块或其他模块中使用。与之相对应的是static关键字，被它修饰的全局变量和函数只能在本模块使用。因此它们不能同时修饰一个变量或函数。
头文件里写 extern int a； 某个cpp文件里写 int a；
然后所有引用了这个头文件的cpp文件里就都可以使用a这个全局变量了。  
即在某个源文件里定义了变量a，在其他源文件里再次声明extern int a，其他源文件就可以使用这个变量a了  

# extern 'C'  
作用：c++和c混合编程，将c++函数按c语言的方式编译，这样c就可以调用该函数了。而c++调用c，extern 'C'的作用是让c++链接器找调用函数的符号时采用c的方式。   
\#ifdef _cplusplus  
extern 'C'{
    代码
}
\#endif
C语言中不支持extern 'C',所以需要条件编译  
表明代码按照C的编译和链接规约来编译和链接，而不是C++。可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。    
c++支持函数重载，在编译时用函数名_参数列表标识函数。变量也是类似，如全局变量可能编译为g_xx，类变量编译为c_xx等。链接时也是按照这种机制去查找相应函数和变量。  
而C语言不支持重载，函数直接编译为函数名标识，这就导致如果c++中使用C语言实现的函数，在链接的时候会出错，提示找不到对应的符号。extern 'C'告诉链接器去寻找C语言符号而不是经过C++修饰的符号。  

# const  
用于变量修饰，表明这个变量不能被修改；  
用于指针修饰，常量指针表明指针的指向物不能被修改；  
用于方法修饰，表明这个方法不会对对象造成改变。  
常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改  
默认情况下，const对象被设定为仅在文件内有效。当多个文件出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。（用extern可以改）  
## const和define的区别  
\#define a 100；
define是预处理指令，define不分配内存，只在预处理过程中做文本替换，define宏没有类型，不做类型检查，可能产生边际效应等错误  
如#define MIN(a, b) a > b ? b : a  
num = b + MIN(num1, num2);
num的值一直是num1、num2两个中的最小值，也就是说讲b的值直接作为0处理了
正确应该为：define MIN(a, b) (a > b ? b : a)   
**有参宏**：#define 宏名（形参表） 字符串 不仅要宏展开还要用形参代替实参。类似模板，但是没有类型检查  

const int a = 100；
const是编译运行阶段使用，修饰的变量，分配内存。const常量有类型，编译器会做类型检查。  
define定义的常量在内存中有若干个拷贝；const定义的常量在程序运行过程中只有一份拷贝，甚至不为普通const常量分配存储空间，而是将它们保存在符号表中，相当于没有了读内存的操作，使得效率也很高  
定义域不同  
定以后能否取消：宏定义可以通过#undef来使之前的宏定义失效，const常量定义后将在定义域内永久有效  
是否可以做函数参数：宏定义不能作为参数传递给函数，const常量可以在函数的参数列表中出现  

## constexpr  
常量表达式是指值不会改变并且再编译过程就能得到计算结果的表达式。字面值属于常量表达式。声明为constexpr由编译器来验证变量的值是否是常量表达式。  

## mutable  
1. mutable只能用来修饰类的非静态数据成员，允许包含它的对象被声明为const时仍可修改声明为mutable的类成员。因此被mutable修饰的数据成员，可以在const成员函数中修改  
2. 用在lambda表达式里，使得函数体可以修改值捕获的变量  

# long，int,short,float,double分别是占多少字节  
具体与机器、OS、编译器有关
                64位机器、g++编译器、windows
char                    1
short                   2
int                     4
long                    4
long long               8
float                   4
double                  8
long double             16
# volatile 易变   
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。
int volatile a；
当要求使用a时，系统总是重新从它所在的内存读取数据（非volatile可以在寄存器中取值），即使它面前的指令刚刚从该处读取过数据。  
一般说来，volatile用在如下的几个地方： 
1) 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
2) 多任务环境下各任务间共享的标志应该加volatile； 
3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；  

# 指针
## 空悬指针  
指向已经释放或者收回的内存的地址  

## 野指针  
未初始化的指针  

## 函数指针 
每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。  

# 数组和指针的区别  
比如对于int a[4]  
数组名a在两种情况下不能当做指向首地址的指针：
1. sizeof(a) 
2. &a 得到的不是指向指针的指针，而是指向长度为4的int数组的指针，即int（*）[4]  
这两种情况下，a是单独的类型，即“长度为4的int数组类型”  

数组名是一个地址，而非指针：
指针可以pointer++，数组名不可以  
指针可以赋值再指向别人，数组名不可以  

char p[] = "hello" 用hello初始化数组p[6],内存位置在栈上,sizeof(p)为8（64位机）  
char* p = “hello"  p是指向字符串字面量的指针，字符串字面量存储在静态存储区，修改会导致未定义行为  
# 类型转换  
1. const_cast  
只能改变运算对象的底层const，将const转为非const，和将非const转为const     

2. static_cast  
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。由于不提供运行时检查，所以叫static_cast  
（1）用于父类和子类的指针/引用转换：  
进行向上转换，把子类对象的指针转换成父类的指针，这种转换是安全的  
进行向下转换，把父类对象的指针转换成子类的指针，这种转换是不安全的  

3. dynamic_cast  
dynamic_cast<type*>(e) 如果失败，返回0   
dynamic_cast<type&>(e)  如果失败，抛出bad_cast异常  
dynamic_cast<type&&>(e)  如果失败，抛出bad_cast异常  
e的类型必须符合下面三个的其中一个：
（1） e的类型是目标type的公有派生类  
（2） e的类型是目标type的公有基类  
（3） e的类型就是目标type的类型  
type必须是类类型，并且通常情况下该类型应该含有虚函数。因为运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。


dynamic_cast在向下转换时，会检查转换的类型，相比static_cast更安全。  

4. reinterpret_cast  
为运算对象的位模式提供较低层次上的重新解释。非常不安全  

# 指针和引用的区别  
1. 指针本身是对象，会分配内存，存储的是指针指向对象的地址；引用是对象的别名，不额外占内存
2. 指针可以初始化为NULL，引用必须初始化，必须绑定到一个对象上  
3. 非const指针可以改变指向的对象，而引用不能改变  
4. 对解引用才是对指针指向的对象进行操作，对引用的所有操作直接作用在绑定的对象上  

