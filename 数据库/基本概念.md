# 事务  
原子性的一组查询。这组查询里的语句要么全部执行成功，要么全部执行失败。  
【START TRANSACTION（开始一个事务）;......(一组语句）；COMMIT（提交事务，将修改的数据持久保留）/ROLLBACK（撤销所有改变）】  
## ACID  
###原子性
整个事务的所有操作要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像整个事务没有被执行过一样  

MySQL 通过undo log（回滚日志） 实现原子性  
每当执行一条insert，回滚日志里就添加一条DELETE，每一条UPDATE也都对应了一条相反的UPDATE  
另外在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因   
###一致性
数据库总是从一个一致性的状态转移到另一个一致性的状态  
###隔离性
并发执行的事务不能相互干扰，一个事务所做的修改在最终提交以前，对其他事务是不可见的  
有四种隔离级别：
1. 读未提交  
事务中的修改，即使没有提交，对其他事务也都是可见的  
**脏读** 问题：读取未提交的数据  

2. 读已提交  
一个事务开始时，只能看见已经提交的事务所做的修改  
大多数数据库（不包括MySQL）的默认隔离级别是读已提交  
**不可重复读** 在一个事务里两次执行相同的查询，因为中间有别的事务提交了，可能会得到不一样的结果  

3. 可重复读  
保证了在同一个事务里多次读取同样的记录的结果是一致的  
MySQL的默认隔离级别  
**幻读**：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。  
在快照读情况下， InnoDB通过多版本并发（MVCC）可以解决幻读的问题   
在当前读情况下，InnoDB通过next-key来避免幻读  

4. 可串行化  
通过强制事务串行执行，避免了前面说的幻读的问题。会在读取的每一行数据上都加锁，这可能导致大量的超时和锁争用的问题  


###持久性
一旦事务提交，则其所做的所有的修改就会永久保存在数据库中  

# 选择合适的引擎  
事务  
备份  
崩溃恢复  
特有的特性  
# MySQL的数据类型  
整数： TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别占8,16,24,32,64位，还可以加上UNSIGNED表示无符号数
实数： 可以使用DECIMA存储比BIFINT还大的数。浮点数(FLOAT, DOUBLE)存储计算不精确，DECIMAL精确计算代价高（CPU不支持对DECIMA的直接计算，由MySQL服务器自身实现了  
字符串：和存储引擎的具体实现有关  
VARCHAR：可变长字符串。需要额外的一个或两个字节记录长度。UPDATE时，可能比原来长，原来的页可能放不下，InnoDB需要分裂页来使行可以放进页内。会保留末尾空格。    
CHAR： 定长字符串。不保留末尾空格。  
VARBINARY、BINARY：二进制字符串
BLOB：二进制字符串
TEXT：字符型字符串
枚举ENUM
时间：DATETIME TIMESTAMP
位数据：BIT SET  


# 主键、外键、超键、候选键   

## 主键  
主键的作用是唯一标识一条记录  
原则： 
1. 主键不可修改   
对于数据库来说，主键可以修改。但是对于业务来说，不能修改主键。主键可能做其他表的外键，如果没有添加外键约束，修改主键会导致数据完整性直接被破坏  
2. 业务字段不可用于主键  
例如，用户表的email是唯一的，但是如果用它作主键，就会导致其他表到处引用email字段，从而泄漏用户信息  
主键必须使用单独的，完全没有业务含义的字段  

对InnoDB存储引擎来说，自增ID比较适合做主键：
1. InnoDB中的主键是聚簇索引，会把相邻主键的数据安放在相邻的物理存储上。uuid是无序的，插入数据时，页的位置会发生变化，页分裂，速度慢  
2. uuid（32个16进制数字，形式为8-4-4-4-12的32个字符）占的空间大，并且InnoDB中别的索引还都要包含主键的值，那么每个索引的空间也都会增加，占的空间大。

# 多表聚簇文件组织  

# 索引
是存储引擎用于快速找到记录的一种数据结构  

## 唯一索引、聚簇（clustering）索引、组合索引  
用于在文件中查找记录的属性或属性集称为搜索码（search key）  
### 聚簇索引/主索引
如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引。在MySQL中当表有聚簇索引时，它的数据行实际上存放在索引的叶子页。【聚簇索引与辅助索引不同的是叶子节点存放的是否是一整行的信息，由于InnoDB存储引擎表是索引组织表，InnoDB的辅助索引的“书签”就是相应行数据的聚集索引键】    

### 组合（联合）索引  
对表上的多个列进行索引  


### 覆盖索引  
辅助索引包含所有满足查询需要的数据的，不需要回表操作  


## B+树索引  
对于低选择性的字段（如性别只有男女）没有必要使用B+树索引。相反对于取值范围很广，几乎没有重复的字段，使用B+树索引很合适。 可以通过观察SHOW INDEX 结果中的列Cardinality【基数，表示索引中不重复记录数量的预估值】  

### B+树索引的分裂  


## 哈希索引  
【memory引擎的默认索引类型是哈希索引】  
InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引  


# 视图  

# 悲观锁 

# 乐观锁  

# 范式  
对于函数依赖（FD） W->A（W、A是表中的一个或多个属性的集合，若FD成立则说表满足该函数依赖，A函数依赖于W）    
对一个实例中的所有元祖对t1和t2，若t1[W] = t2[W],则t1[A] = t2[A]，则说该实例满足函数依赖W->A  
如果存在X包含于W,有X->A成立，那么称W->A是局部依赖，否则为完全依赖   
如果关系上的一个约束对所有关系实例都成立，且与其他约束无关，则称其为平凡的  
W->A，其中A是W的子集，则W->A是平凡的  
如果Z函数依赖于Y，Y函数依赖于X，则Z传递函数依赖于X  
**包含在任何一个候选键里的属性都是主属性**   

## 第一范式  
每个关系的属性值为不可分的原子值。如果不满足第一范式，就不是关系型数据库  


如果仅符合第一范式，会存在下列问题：  
假定选课关系表为SelectCourse(学号, 姓名, 系名, 系主任，课程名称, 成绩)，关键字为组合关键字(学号, 课程名称)，因为存在课程名称->学分，学号->姓名，年龄  所以不满足第二范式  
1. 冗余  
比如同一门课程由n个学生选修，“学分”就重复了n-1次，同一个学生选修了m门课程，姓名和年龄就重复了m-1次  
2. 更新异常    
可能修改了某个元祖的信息但是没有修改其他元祖中的其他信息    
3. 删除异常  
假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，系名、系主任和课程名称信息也被删除了。很显然，这也会导致插入异常。  
4. 插入异常  
假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。  


## 第二范式  
满足第一范式，消除非主属性部分函数依赖于候选键，非主属性必须完全函数依赖于候选键  
第二范式就是要求要有主键，其他属性都完全函数依赖于主键  
消除部分函数依赖的办法是将大数据表拆分成小数据表，这个过程叫做模式分解  
如上例可分解为（学号，姓名，系名，系主任），（学号，课程名称，成绩)  
冗余有改进、更新异常有改进  
删除异常无改进，插入异常无改进        

## 第三范式   
满足第二范式，消除非主属性对候选键的传递依赖  
上例学号->系名，系名->系主任，不满足第三范式  
可以再拆成（学号，姓名，系名），（系名，系主任）

## BC范式  
满足第二范式，消除每一属性对候选键的传递依赖  
与第三范式的区别是第三范式存在主属性对候选键的传递依赖   

## 第四范式   
满足BCNF，消除非平凡且非函数依赖的多值依赖  

# 范式的优点和缺点 
优点： 
1. 范式化的更新操作通常比反范式化更快  
2. 范式化的数据冗余少，更新只需要修改更少的数据  
3. 范式化的表通常更小，更容易放进内存里  
4. 更少需要DISTINCT和GROUP BY  
缺点：
通常需要JOIN，这不但代价昂贵，而且可能使一些索引策略无效。例如范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引  

# 反范式的优点和缺点  
优点：
反范式因为所有的数据都在一张表中，可以避免JOIN  
单独的表也可以使用更有效的索引策略  
缺点：
数据冗余  
更新麻烦  


# 分片、分区、分表、分库  






