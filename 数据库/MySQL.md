# MySQL的特点  
关系型数据库：用表的集合来表示数据和数据间的关系。每个表有多个列，每列有唯一的列名。  
单进程多线程（Oracle是多进程）    
插件式的存储引擎架构  

# 数据引擎  
InnoDB：支持事务  
MyISAM：不支持事务  

# InnoDB特点  
支持事务、支持外键、行锁设计、默认读取操作不会产生锁  


# MVCC  
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的  
通过在每行记录后面保存两个隐藏的列来实现。一个列保存了行的创建时间，一个保存行的过期时间（删除时间）【存储的并不是实际的时间值，而是系统版本号】每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较  
## 在可重复读隔离级别下，MVCC具体操作
SELECT  
1. 只查找系统版本号小于等于事务的系统版本号的数据行。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的  
2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除  
INSERT  
为插入的每一行保存当前系统版本好作为行版本号  
DELETE  
为删除的每一行保存当前系统版本号作为行删除标识  
UPDATE  
插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识  
## 优点  
使大多数读操作可以不用加锁  



# InnoDB的锁  
## 共享锁（s锁）和独占锁（排他锁、x锁）  
行级锁  
共享锁允许持锁事务读取一行   
排他锁允许持锁事务更新或者删除一行   

## 意向锁（I锁）  
表级锁  
意向排他锁（IX锁）表明一个事务意图在某个表中设置某些行的X锁  
意向共享锁（IS锁）表明一个事务意图在某个表中设置某些行的S锁  
如 SELECT ... LOCK SHARE MODE 设置一个IS锁  
SELECT ... FOR UPDATE  设置一个IX锁  
一个事务必须先持有该表上的IS或者更强的锁才能持有该表中某行的S锁  
一个事务必须先持有该表上的IX锁才能持有该表中某行的X锁  
意向锁只会阻塞全表请求（如LOCK TABLES ... WRITE)

**新请求的锁只有兼容已有的锁才能被允许，否则必须等待不兼容的已有锁被释放。一个不兼容的锁请求不被允许是因为它会引起死锁**  

## 记录锁  
记录锁针对索引记录     
SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE 阻止其他事务插入、修改或者删除t.c1等于10的行  
记录锁总是锁定索引记录，即使表没有索引（这种情况下，InnoDB会创建隐式索引，并使用这个索引实施记录锁）  

## 间隙（gap）锁  
锁定一段范围的索引记录，第一个索引记录之前或者最后一个索引记录之后的间隔上的锁
如 SELECT c1 FROM t WHERE c1 BETWEEN 10 AND 20 FOR UPDATE 10到20范围内的所有值都不上锁，不能插入、删除、修改索引在这个范围内的记录  
一个间隙可能是一个索引值、多个索引值，甚至是空的  
只使用于部分事务隔离级别  


## next-key锁  
是记录锁和间隙锁的组合  
假设一个索引包含值 10,11,13和20，索引上可能的NK 锁包括如下几个区间（注意开闭区间）
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)


